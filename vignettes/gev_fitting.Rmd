---
title: "Fitting of the GEV distribution"
author: "Philipp MÃ¼ller"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Fitting of the GEV distribution}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Data import and cleaning
In this basic tutorial I assume the usage of the data downloaded in the first tutorial called *Downloading and formatting of the weather data of the DWD*. Here we will use the daily maximal temperature data.
```{r}
source.data() # interactive data loading
data.list <- stations.temp.max
```

For it quite important for our data to be composed of complete years since we want to extract the annual maximal or minimal values (at least in this tutorial). Since it would yield a strong artifact if a particular year just contains values in one specific season we first remove all incomplete years.
As a second step we will calculate the anomalies of the data and discard all time series containing less than 30 years. Else we would have less than 30 points to fit our three GEV parameters to.

```{r}
## Removal of the incomplete years
## To boost the performance of the code I will work with the parallel version of the lapply function
## but it will still takes some time
data.complete <- mclapply( data.list, remove.incomplete.years, mc.cores = detectCores() )

## Remove all series containing less than 30 years
data.cleaned <- data.complete[ Reduce( c, mclapply( data.complete, function( x )
    length( unique( year( x ) ) ), mc.cores = detectCores() ) ) >= 30 ]

## calculate the anomalies of the data
data.anomalies <- mclapply( data.cleaned, anomalies )
```

After we have some nice time series we will block them in annual blocks and extract their maximal values. Those are than fitted with the generalized extreme value (GEV) function and the 100 year return levels will be extracted.

```{r}
## blocking of the data
data.blocked <- mclapply( data.anomalies, block, mc.cores = detectCores() )

## fitting of the GEV function using maximum likelihood
data.fitted <- mclapply( data.blocked, gev.fit, mc.cores = detectCores() )

return.levels <- Reduce( c, lapply( data.fitted, function( x ) x$return.level ) )
ggplot() + geom_point( data = data.frame( station.name = names( data.blocked ),
                                        return.level = return.levels ),
                     aes( y = station.name, x = return.level ) )
```

There are also some nice options to visualize the time series and the fitting results
```{r}
ttplot( data.blocked[[ 50 ]] )

plot( data.fitted[[ 50 ]] )
```
